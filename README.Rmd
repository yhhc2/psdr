---
output: github_document
always_allow_html: true
---

<!-- README.md is generated from README.Rmd. Please edit that file -->


## Overview

Author: Yong-Han Hank Cheng

This package allows you to generate and compare power spectral density (PSD)
plots given time series data. FFT is used to take a time series data, analyze
the oscillations, and then output the frequencies of these oscillations in the
time series in the form of a PSD plot.

## Installation

```{r, eval = FALSE}
# Install the package from GitHub
devtools::install_github("yhhc2/psdr")
```

```{r}
# Load package
library("psdr")

#For displaying data table
library(kableExtra)
library(magrittr)

```

## Usage

Visit the package's website for function reference: <https://yhhc2.github.io/psdr/>

## Installation

```{r, eval = FALSE}
# Install the package from GitHub
devtools::install_github("yhhc2/psdr")
```

```{r}
# Load package
library("psdr")
```

## Example

This is an example of how this package can be used to take a dataframe with
multiple separate time series belonging to 2 categories (A and B), separate out the 
time series, and use the time series to make PSDs and compare the dominant
frequencies between the two categories of signals.

### Load in example dataset

In this example dataset, there are 3 time series for each category (6 signals total). 
Here is how the package can be used to take a dataframe and split it into multiple
dataframes, with each dataframe as a separate time series.

```{r}

example_data <- GenerateExampleData()

#Only displays on html
rmarkdown::paged_table(example_data)

#kable(example_data, booktabs = TRUE, longtable = TRUE)

#print(example_data, max.tbl.height = 100)

example_data_windows <- GetHomogeneousWindows(example_data, "Session", c("Session"))

```

### Explore the dataset

Plotting all the time series for category A on a single plot and plotting time 
series data for category B on a single plot shows that the frequencies of 
signals in category A are higher. 

Plot signals for category A
```{r}

plot_result <- ggplot2::ggplot(subset(example_data, example_data$Category=="A"), ggplot2::aes(x = Time, y = Signal, colour = Session, group = 1)) + ggplot2::geom_line()

plot_result

```


Plot signals for category B
```{r}

plot_result <- ggplot2::ggplot(subset(example_data, example_data$Category=="B"), ggplot2::aes(x = Time, y = Signal, colour = Session, group = 1)) + ggplot2::geom_line()

plot_result


```


This remains true when the time series for each category are averaged.

```{r}

FirstComboToUse <- list( c(1, 2, 3), c("A") )

SecondComboToUse <- list( c(4, 5, 6), c("B") )

timeseries.results <- AutomatedCompositePlotting(list.of.windows = example_data_windows,
                           name.of.col.containing.time.series = "Signal",
                           x_start = 0,
                           x_end = 999,
                           x_increment = 1,
                           level1.column.name = "Session",
                           level2.column.name = "Category",
                           level.combinations = list(FirstComboToUse, SecondComboToUse),
                           level.combinations.labels = c("A", "B"),
                           plot.title = "Comparing category A and B",
                           plot.xlab = "Time",
                           plot.ylab = "Original units",
                           combination.index.for.envelope = NULL,
                           TimeSeries.PSD.LogPSD = "TimeSeries",
                           sampling_frequency = NULL)

ggplot.obj.timeseries <- timeseries.results[[2]]

ggplot.obj.timeseries

```



### Visualize the frequency contribution of signals

Looking at the time series data, we can tell the frequencies of oscillations are 
different between the time series. To determine which frequencies are contributing
to each time series, we can plot the PSDs for each time series.

PSD for signals in session A
```{r}

data1 <- example_data_windows[[1]]
psd_results1 <- MakePowerSpectralDensity(100, data1$Signal)

data2 <- example_data_windows[[2]]
psd_results2 <- MakePowerSpectralDensity(100, data2$Signal)

data3 <- example_data_windows[[3]]
psd_results3 <- MakePowerSpectralDensity(100, data3$Signal)

Frequency <- c(psd_results1[[1]], psd_results2[[1]], psd_results3[[1]])
PSD <- c(psd_results1[[2]], psd_results2[[2]], psd_results3[[2]])
Session <- c(rep(1, length(psd_results1[[1]])), rep(2, length(psd_results1[[1]])), 
             rep(3, length(psd_results1[[1]])))

data_to_plot <- data.frame(Frequency, PSD, Session)

plot_results <- ggplot2::ggplot(data=data_to_plot, ggplot2::aes(x=Frequency, y=PSD, color = factor(Session), group=1)) +
  ggplot2::geom_point() + ggplot2::geom_path() + ggplot2::xlim(0,3)

plot_results

```


PSD for signal in session B
```{r}


data1 <- example_data_windows[[4]]
psd_results1 <- MakePowerSpectralDensity(100, data1$Signal)

data2 <- example_data_windows[[5]]
psd_results2 <- MakePowerSpectralDensity(100, data2$Signal)

data3 <- example_data_windows[[6]]
psd_results3 <- MakePowerSpectralDensity(100, data3$Signal)

Frequency <- c(psd_results1[[1]], psd_results2[[1]], psd_results3[[1]])
PSD <- c(psd_results1[[2]], psd_results2[[2]], psd_results3[[2]])
Session <- c(rep(1, length(psd_results1[[1]])), rep(2, length(psd_results1[[1]])), 
             rep(3, length(psd_results1[[1]])))

data_to_plot <- data.frame(Frequency, PSD, Session)

plot_results <- ggplot2::ggplot(data=data_to_plot, ggplot2::aes(x=Frequency, y=PSD, color = factor(Session), group=1)) +
  ggplot2::geom_point() + ggplot2::geom_path() + ggplot2::xlim(0,3)

plot_results

```


To get a single composite PSD for each category, we can take the average.

```{r}

FirstComboToUse <- list( c(1, 2, 3), c("A") )

SecondComboToUse <- list( c(4, 5, 6), c("B") )

PSD.results <- AutomatedCompositePlotting(list.of.windows = example_data_windows,
                           name.of.col.containing.time.series = "Signal",
                           x_start = 0,
                           x_end = 5,
                           x_increment = 0.01,
                           level1.column.name = "Session",
                           level2.column.name = "Category",
                           level.combinations = list(FirstComboToUse, SecondComboToUse),
                           level.combinations.labels = c("A", "B"),
                           plot.title = "Comparing category A and B",
                           plot.xlab = "Hz",
                           plot.ylab = "(Original units)^2/Hz",
                           combination.index.for.envelope = NULL,
                           TimeSeries.PSD.LogPSD = "PSD",
                           sampling_frequency = 100)

ggplot.obj.PSD <- PSD.results[[2]]

ggplot.obj.PSD

```



### Comparing frequency contribution of each category

We know there are differences in frequencies of signals between category A and
B, but we want to statistically test if the difference is significant. 

```{r}

comparison_results <- PSD.results[[3]]

dominant_freq_for_comparison <- comparison_results[[1]]

kruskal_wallis_test_results <- comparison_results[[2]]

wilcoxon_rank_sum_test_results <- comparison_results[[3]]

```

Since multiple signals are present in each category, we want to 
see if the dominant frequencies in signals of category A are signficantly
different from the dominant frequencies in signals of category B

```{r}
dominant_freq_for_comparison
```

The comparison can be performed using the Kruskal-Wallis rank sum test. Here,
the p-value indicates the difference is statistically significant. 

```{r}
kruskal_wallis_test_results
```

In this example, only two categories are used. However, Kruskal-Wallis rank
sum test can be used for multiple categories, similar to ANOVA. If more than
two categories are used, pair-wise testing using Wilcoxon rank sum exact test
can be used to see which two categories are significantly different.

```{r}
wilcoxon_rank_sum_test_results
```


